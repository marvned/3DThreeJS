<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üî• –ù–µ–æ–Ω–æ–≤—ã–π 3D –º–∏—Ä —Å —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏</title>
<style>
  body, html { margin:0; height:100%; overflow:hidden; background: #000; }
  canvas { display:block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/geometries/TextGeometry.js"></script>

<script>
  // --- Setup scene ---
  const scene = new THREE.Scene();

  // –ö–∞–º–µ—Ä–∞
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 10, 40);

  // –†–µ–Ω–¥–µ—Ä
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(new THREE.Color(0x0b0020));
  document.body.appendChild(renderer.domElement);

  // –û—Ä–±–∏—Ç –∫–æ–Ω—Ç—Ä–æ–ª—ã
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;

  // --- –°–≤–µ—Ç ---
  const ambientLight = new THREE.AmbientLight(0x202040, 0.6);
  scene.add(ambientLight);

  const pointLight = new THREE.PointLight(0xff33cc, 1.5, 100);
  pointLight.position.set(0, 15, 15);
  scene.add(pointLight);

  // –ü—É–ª—å—Å–∏—Ä—É—é—â–∏–π —Å–≤–µ—Ç
  let pulseSpeed = 0.02;

  // --- –ù–µ–æ–Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç ---
  let neonText;
  const fontLoader = new THREE.FontLoader();
  fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.137.5/examples/fonts/helvetiker_regular.typeface.json', font => {
    const textGeo = new THREE.TextGeometry('NEON GAME', {
      font: font,
      size: 5,
      height: 1,
      curveSegments: 12,
    });
    textGeo.center();

    const neonMat = new THREE.MeshBasicMaterial({
      color: 0xff00cc,
      transparent: true,
      opacity: 0.8,
      emissive: 0xff00cc
    });

    neonText = new THREE.Mesh(textGeo, neonMat);
    scene.add(neonText);
  });

  // --- –ß–∞—Å—Ç–∏—Ü—ã (–º–∞–≥–∏—á–µ—Å–∫–∏–π –ø–æ—Ç–æ–∫) ---
  const particlesCount = 500;
  const particleGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particlesCount * 3);
  for(let i=0; i<particlesCount; i++) {
    positions[i*3] = (Math.random()-0.5)*40;
    positions[i*3+1] = (Math.random()-0.5)*20 + 10;
    positions[i*3+2] = (Math.random()-0.5)*40;
  }
  particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  const particleMaterial = new THREE.PointsMaterial({
    color: 0xff33cc,
    size: 0.15,
    transparent: true,
    opacity: 0.7,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });

  const magicParticles = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(magicParticles);

  // --- –§–æ–Ω: –ø–ª–∞–≤–Ω—ã–π –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç (—Å –ø–æ–º–æ—â—å—é –ø—Ä–æ—Å—Ç–æ–≥–æ –ø–ª–∞–Ω–∞ –∏ —à–µ–π–¥–µ—Ä–∞) ---
  const vertexShader = `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `;

  const fragmentShader = `
    varying vec2 vUv;
    uniform float time;
    void main() {
      vec3 color1 = vec3(0.0, 0.0, 0.3);
      vec3 color2 = vec3(0.6, 0.0, 0.6);

      float wave = sin(vUv.y * 20.0 + time * 3.0) * 0.1;
      vec3 color = mix(color1, color2, vUv.y + wave);

      gl_FragColor = vec4(color, 1.0);
    }
  `;

  const bgGeometry = new THREE.PlaneGeometry(100, 100);
  const bgMaterial = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: {
      time: { value: 0 }
    },
    depthWrite: false
  });

  const bgPlane = new THREE.Mesh(bgGeometry, bgMaterial);
  bgPlane.position.z = -50;
  scene.add(bgPlane);

  // --- –ü–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞: bloom –¥–ª—è —Å–≤–µ—á–µ–Ω–∏—è ---
  const composer = new THREE.EffectComposer(renderer);
  const renderPass = new THREE.RenderPass(scene, camera);
  composer.addPass(renderPass);

  const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.5, 0.4, 0.85
  );
  bloomPass.threshold = 0;
  bloomPass.strength = 1.5;
  bloomPass.radius = 0.6;
  composer.addPass(bloomPass);

  // --- –†–µ–∞–∫—Ü–∏—è —á–∞—Å—Ç–∏—Ü –Ω–∞ –º—ã—à—å ---
  const mouse = new THREE.Vector2(0, 0);
  window.addEventListener('mousemove', e => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;
  });

  // --- –ê–Ω–∏–º–∞—Ü–∏—è ---
  function animate(time=0){
    requestAnimationFrame(animate);

    // –ü—É–ª—å—Å–∏—Ä—É–µ–º —Å–≤–µ—Ç
    pointLight.intensity = 1 + Math.sin(time * pulseSpeed) * 0.8;

    // –ê–Ω–∏–º–∏—Ä—É–µ–º —á–∞—Å—Ç–∏—Ü—ã
    const pos = particleGeometry.attributes.position.array;
    for(let i=0; i<particlesCount; i++) {
      pos[i*3+1] -= 0.05; // –ø–∞–¥–∞—é—Ç –≤–Ω–∏–∑
      if(pos[i*3+1] < 0) pos[i*3+1] = 20;

      // –º–∞–≥–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏–µ –∫ –º—ã—à–∏ (–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ + –Ω–µ–º–Ω–æ–≥–æ –∫–æ–ª–µ–±–∞–Ω–∏—è)
      pos[i*3] += (mouse.x * 20 - pos[i*3]) * 0.02 + (Math.random()-0.5)*0.02;
      pos[i*3+2] += (mouse.y * 20 - pos[i*3+2]) * 0.02 + (Math.random()-0.5)*0.02;
    }
    particleGeometry.attributes.position.needsUpdate = true;

    // –ü–ª–∞–≤–Ω–æ –≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—Å—Ç, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
    if(neonText) {
      neonText.rotation.y += 0.005;
      neonText.material.opacity = 0.7 + Math.sin(time * 0.002) * 0.3;
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º uniform –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞
    bgMaterial.uniforms.time.value = time * 0.001;

    controls.update();
    composer.render();
  }
  animate();

  // --- –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Å–∞–π–∑–∞ ---
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
